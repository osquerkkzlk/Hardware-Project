# 硬件主文件

## 1、STM32

### 1、GPIO读写操作

```c
// 该函数可以把值直接赋给寄存器，因为c语言不支持16进制，所以只能写成2进制的形式，如0x0001(STM32是32位)，可以对其进行按位取反的方式 如~。
GPIO_Write(GPIOA,value) 
```

### 2、杂项

1、stm32的引脚上电后，如果不初始化默认都是浮空输入。

2、oled显示函数，如果显示的值超过了规定长度，那么高位值（前面的值）会被截断

3、c语言支持16进制，不直接支持2进制的数。所以你在 OLED.Show_Bin_Num()里面需要写16进制的数，然后他会默认打印2进制的数。

4、中断响应是正常的流程，引脚电平变化触发中断。事件响应不会触发中断，而是出发别的外设操作，属于外设之间的联合工作。

5、AFIO主要用于引脚复用功能的选择和重定义，在STM32中，AFIO主要完成两个任务：复用功能引脚重映射和中断引脚选择。

6、定时器计数值等于重装值产生的中断，我们称之为更新中断。其产生的事件，我们称为更新事件，它不会触发中断，但会触发其他电路的工作。

7、TIM定时器中断中，外部时钟模式1使用外部输入脚作为计数器时钟的时钟源，而外部始终模式2使用外部触发输入作为计数器时钟的时钟源。

8、定时器一旦  tim_cmd（），即使能之后就会立刻开始计数，如果在配置过程中某些标志位没有及时清除或者NVIC没有准备好，就可能导致中断立刻触发，出现意外中断。

9、对于同一个定时器的同一个通道，输入捕获和输出比较在同一时间只能使用一个。并且每个定时器的ARR和计值相同，不同的只是 CRR。

10、在测量信号频率时，可以选择测频法和测周法。前者的原理是在一定时间内记录上升沿个数，该个数除以时间就是频率，适合高频信号。后者的原理是在待测信号的一个周期内（相邻两个上升沿时间内）记录标准信号上升沿个数，该个数乘上标准信号周期即为待测信号的周期，进而可以求出待测信号的频率，适合于低频信号。中界频率是测频法和测周法误差相等的点 。

![](./中界频率.png)

11、当你把该通道设置为输出比较模式时，你可以设置CCR的值，用于和计数器的值作比较，输出pwm。当你把该通道设置为输入捕获模式是，当发生对应跳变，计数器的值就会写入CCR，通过测周法得到频率。

12、编码器是一个带方向控制的外部时钟，其对于输入信号而言，上升沿和下降沿均有效。输入捕    获模块中的极性选择实际上是高低电平是否反转。

13、c语言中，%取余运算符不能用于浮点数，最好之前进行一个强制类型转换。

14、写传输寄存器时，必须关闭DMA，不能在DMA开启时写传输寄存器。并且DMA的每个通道都支持软件触发与特定的硬件触发。

15、DMA转运有三个条件：传输计数器大于0，触发源有触发信号，DMA使能。

16、ADC转换（连续扫描模式中的每个通道）完成会自动给DMA标志位。不需要我们去手动判断。

17、串口一挂载在APB2总线上，其他串口挂载在APB1总线上。

18、一根线只能有一个输出，但可以有多个输入。

19、双引号包的是字符串，单引号包的是字符。

20、I2C通信中，输入模式就相当于放手SDA，使其处于低电平。在输出模式中，输出高电平就相当于放手SDA，输出低电平就相当于拉低SDA。这一过程通常伴随着应答与非应答。当主机读从机的时候，并且需要读出多个字节数据时，可以在前面给应答，最后给非应答，让从机交出主线控制权。

主机发送从机地址时，最后一位为0表示主机写入从机操作，最后一位为1表示主机读出从机操作。并且一旦主机给读标志位了，下一个时序就要立刻读寄存器，尽管主机来不及指定要读的具体寄存器。在从机中，所有的寄存器会被分配到一个线性区域中，并且会有一个单独的指针变量指示寄存器，上电默认指向零地址，每写入或读出一个字节后，该指针会自动自增一次，移动到下一个位置。当主机设为读操作时，会读从机当前指针指向位置的值，因此我们一般在读操作之前，先用写操作指定寄存器位置。

21、对于  SPI  通信来讲，输出引脚配置为推挽输出（输出高电平迅速，相比I2C是有点），输入引脚配置为浮空或上拉输入。

22、Flash 读写规则。任何修改  Flash  原有数据的操作（包括页编程、扇区擦除、写状态寄存器等操作）前，都必须使能，使标志位 WEL （写允许标志位）置1，在一次写操作或擦除后会自动清零。

每个数据位只能由1改写为0，不能由0改写为1.写入数据前必须先擦除，擦除后，所有数据变为1。擦除必须按最小擦除单元进行。连续写入多字节时，最多写入一页的数据，超过页尾位置的数据会回到页首覆盖写入。写操作结束后，芯片进入忙状态，不响应新的读写操作。

读操作时，可以直接读取时序，无需使能，无需额外操作，没有页的限制。读操作结束后不会进入忙状态，但不能在忙状态时读取。
