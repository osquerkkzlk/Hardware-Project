# Open MV 视觉识别



​																		**作者**： 032310212 郑林郁

## 1、技术原理

---



### 1、设置对比度

```python
sensor.set_contrast(1)
```

对于模板匹配来讲，图像太亮或太暗都会导致匹配效果变差，而对比度正是影响亮暗的主要参数之一。这里，设置对比度为1，使得图像更加清晰，又不会使图像失真。变换公式如下，$\alpha$ 为对比度， $I $ 为原图像。
$$
I_{\text{new}} = \alpha \cdot (I - 128) + 128
$$



### 2、摄像头保持稳定

```python
sensor.skip_frames(time = 1000)
```

摄像丢弃 1 s 的初始帧，待其稳定之后再进行处理。



### 3、关闭白平衡

```python
sensor.set_auto_whitebal(False)
```

摄像头在不同光源下，会自动调整红绿蓝三个通道的增益比例，让图像看起来“自然”，在灰度图像下，虽然颜色本身不重要，但是白平衡仍可能通过传感器信号的增益分配去影响灰度值，影响模板匹配。所以，当我们处理对图像特点有严格要求的任务时，关闭即可。



### 4、设置曝光

```python
Exposure_scale = 1 # 曝光调节尺度
print(f"< 最初曝光 > {sensor.get_exposure_us()}")
sensor.skip_frames(time = 1000)
print(f"< 当前曝光 > {(current_exposure:=sensor.get_exposure_us())}") 
sensor.set_auto_exposure(False,exposure_us = int( current_exposure* Exposure_scale))
```

曝光时间越长，摄像头感光越多，图像就越亮，反之就越暗。选择合适的曝光，会使图像亮度整体合适。我在源代码上进行了优化，使代码简洁且 `pythonic` 。



### 5、图像格式选择

常见的图像格式有很多，在这里，我们只探讨 `pgm`、`bmp`、`jpg`、`png`这四种格式的特点和使用场景，以及为什么我们选择 pgm 作为模板匹配的图像保存格式。

**pgm** :只能存储灰度图，文件体积大，但是加载速度快，读入图片后能直接使用，适合模板匹配。

**bmp**：文件体积大，支持灰度、RGB等格式，适合需要简单读写的任务，一般用于调试和存储中间结果。

**jpg**：有损压缩，会造成细节损失，适合精度要求不高的任务，一般用于展示给人看。

**png**：无损压缩，适合于需要保真但文件不能太大的图像，可以作为模板匹配，但是解码速度不如 pgm 。



### 6、模板匹配

```python
R = img.find_template(template, 0.8, step=1, roi=(50, 0, 60, 50), search=SEARCH_EX)
```

template是用于匹配的模板，0.8是阈值，较高的阈值可以降低错误识别的概率，但是也会降低检测率，较低的阈值则相反。roi是感兴趣区域，step表示在查找模板时要跳过的像素数，可以加快算法速度，默认为2。search是模板匹配的搜索算法，具体介绍如下。

* `SEARCH_EX` 穷举搜索,精度高，速度慢
* `SEARCH_DS ` 随机搜索，首先把模板和roi缩小，找到大致范围再精细搜索



### 7、串口接收

```python
uart = pyb.UART(3, 115200, timeout_char = 1000) # 初始化串口
data[i]= uart.readchar()
```

串口定义中，参数 `timeout_char` 表示，接收字节的时间为 1000 ms,超时会认为无数据发送。并且要注意的是，串口接收函数返回的是一个十进制值（int），表示接收到的单个字节的 ASCII 值。



### 8、ROI 误区

```python
sensor.set_windowing((0, 50, 160, 50))
```

该函数会把摄像头捕捉到的图片裁剪到该函数，之后的函数，用到的 roi 都是在这个基础上限定感兴趣区域的。



### 9、增益

```python
sensor.set_gainceiling(16)  # 设置自动增益
......
sensor.set_auto_gain(False)  # 关闭自动增益
```

打开摄像头后，开启自动增益，使其根据环境自动找到合适的参数，之后我们关闭它以防止干扰图像。





### 10、详解任务一

```python
# 识别目标数字
if Find_Task == 1:
    temp=[FirstFindTemplate(img) for img in template_base]
    if not any(temp): continue
    [(roi,idx)]=[(returned_roi,i) for i,returned_roi in enumerate(temp) if returned_roi]
    FirstFindedNum(roi,idx+1)
```

本代码使用了大量的列表推导式，首先进行了模板匹配，并把结果存储在 temp 变量中。之后判断temp是否都是None，如果是的表示并未匹配到模板，直接退出即可。之后对 temp 进行了解析，找出有效 roi 和他的索引，因为我在代码的开头对模板进行了排序，所以 此时的 索引+1 就是真实的数字。之后调用函数，发送给主控，并框出该数字。



### 11、详解任务二

```python
# 任务2 :
elif Find_Task == 2:
    # Target_Num是目标数字
    if LoR==0:
        ROI_L=FindTemplateL(template_L[Target_Num-3])
        ROI_R=FindTemplateL(template_L[Target_Num-3])
        ROI_LL=FindTemplateL(template_L[Target_Num-3])
        ROI_RR=FindTemplateL(template_L[Target_Num-3])
    if not LoR and any(ROI:=[ROI_L,ROI_R,ROI_LL,ROI_RR]):
        Target_ROI=[roi for roi in ROI if roi][0]
        FindedNum(Target_ROI,Target_Num)
```

 本代码对源代码进行了优化，使得代码简洁，逻辑清晰。首先，判断 LoR是否为0，如果是的话再进行模板是别。因为之前对模板进行了排序，使得我们可以直接用 `Target_Num-1` 表示目标数字对应的索引，进而直接找到特定模板。然后，我们判断是否匹配到模板，也就是判断是否  ROI 非空，之后用列表推导式找到目标 ROI，把信息发送给主控。



## 2、代码部分

---



```python
import time, image,sensor,math,pyb,ustruct
from image import SEARCH_EX, SEARCH_DS
from pyb import Pin, Timer,LED
import os


# part1
#-------------------------- 基本配置 ----------------------------
sensor.reset()  # 重置摄像头到初始配置
sensor.set_contrast(1)   # 设置对比度
sensor.set_gainceiling(16)  # 设置自动增益
sensor.set_framesize(sensor.QQVGA) # 160 x 120 ，减小计算量
sensor.set_pixformat(sensor.GRAYSCALE)  # 模板匹配要求灰度图
sensor.set_windowing((0, 50, 160, 50))  # 直接设置感兴趣区域，减小计算量
sensor.set_auto_gain(False)  # 关闭自动增益
sensor.set_auto_whitebal(False)  # 关闭白平衡

Exposure_scale = 1 # 曝光调节尺度
print(f"< 最初曝光 > {sensor.get_exposure_us()}")
sensor.skip_frames(time = 1000)
current_exposure=sensor.get_exposure_us()
print(f"< 当前曝光 > {current_exposure}")
sensor.set_auto_exposure(False,exposure_us=int(current_exposure* Exposure_scale))

uart = pyb.UART(3, 115200, timeout_char = 1000) # 初始化串口

#------------------------ 基本配置 -----------------------


# part2
#--------------------- 参数初始化及读取模板 -------------

Find_Task = 2
Target_Num = 4
find_flag = 0
x = 0
data = [0x00]*8
LoR=0
dir=r"/Template"

# 图片读入
template_base,template_L,template_R,template_LL,template_RR=[],[],[],[],[]
for img_path in sorted(os.listdir(dir),reverse=False):
    value=img_path.split(".")[0]
    value=value if len(value)==1 else value[1:]
    img=image.Image(dir+"/"+img_path)
    index=-1
    if value in ["L","R","LL","RR"]:
        index=["L","R","LL","RR"].index(value)
    else:
        index=-1
    [template_L,template_R,template_LL,template_RR,template_base][index].append(img)

#---------------------- 参数初始化及读取模板 -------------
# 检验代码
# for tem in [template_L,template_R,template_LL,template_RR,template_base]:
#     print(f"{len(tem)}")


# part3
#------------------- 功能函数定义 --------------------

def UartReceiveDate():
    '''
    UART接收函数,同时对收到的数据进行解码，返回任务和目标数字
    '''
    global Find_Task
    global Target_Num
    global x
    global data

    for i in range(8):data[i]= uart.readchar()

    if  x < 5 and data[x] == 42 and data[x+3] == 38:
        Find_Task =  data[x+1]
        Target_Num = data[x+2]
        Find_Task =  Find_Task - 48
        Target_Num = Target_Num - 48
        x = 0
    elif x >= 5: x = 0
    x+=1
    # print(f"\n< 任务码 > {Find_Task}")
    # print(f"< 目标数字 > {Target_Num}\n")

def FirstFindTemplate(template):
    '''
    寻找目标数字,并返回数字边框
    '''
    return img.find_template(template, 0.8, step=1, roi=(50, 0, 60, 50), search=SEARCH_EX)

def FirstFindedNum(R, Finded_Num):
    '''
    画出数字矩形框,并把【目标数字，方向控制，识别标志，当前任务】发送给主控
    '''
    global Find_Task
    global find_flag
    img.draw_rectangle(R, color=(225, 0, 0))
    find_flag = 1
    Num = Finded_Num
    FH = bytearray([0x2C,0x12,Num, LoR, find_flag, Find_Task,0x5B])
    uart.write(FH)
    print("目标病房号：", Num)

def FindTemplateL(template):
    '''
    左侧模板识别，并返回数字框
    '''
    return img.find_template(template, 0.5, step=1, roi=(0, 0, 70, 50), search=SEARCH_EX)
def FindTemplateR(template):
    '''
    右侧模板识别，并返回数字框
    '''
    R = img.find_template(template, 0.5, step=1, roi=(90, 0, 70, 50), search=SEARCH_EX)
    return R
def FindTemplateLL(template):
    '''
    左左侧模板识别，并返回数字框
    '''
    R = img.find_template(template, 0.5, step=1, roi=(0, 0, 70, 50), search=SEARCH_EX)
    return R
def FindTemplateRR(template):
    '''
    右右侧模板识别，并返回数字框
    '''
    R = img.find_template(template, 0.79, step=1, roi=(90, 0, 70, 50), search=SEARCH_EX)
    return R
def FindedNum(R, Finded_Num):
   global Find_Task
   global find_flag
   '''
   调整小车方向
   '''
   img.draw_rectangle(R, color=(225, 0, 0))
   if R[0] >90:
       LoR = 2
   elif 0< R[0]<60:
       LoR = 1
   else:
       LoR= 0
   find_flag = 1
   Num = Finded_Num
   if LoR>0:
       FH = bytearray([0x2C,0x12,Num, LoR, find_flag, Find_Task,0x5B])
       uart.write(FH)
       print("识别到的数字是：", Num, "此数字所在方位：", LoR)
#-------------------- 功能函数定义 --------------------


# part4
#-------------------- 主函数 -------------------------

while (True):
    img = sensor.snapshot()
    UartReceiveDate()
    # 任务0 : 直走
    if Find_Task == 0:
        LoR=0
    # 任务1 : 识别目标数字
    if Find_Task == 1:
        temp=[FirstFindTemplate(img) for img in template_base]
        if not any(temp): continue
        [(roi,idx)]=[(returned_roi,i) for i,returned_roi in enumerate(temp) if returned_roi]
        FirstFindedNum(roi,idx+1)
    # 任务2 :
    elif Find_Task == 2:
        print(LoR)
        # Target_Num是目标数字
        if LoR==0:
            ROI_L=FindTemplateL(template_L[Target_Num-3])
            ROI_R=FindTemplateR(template_R[Target_Num-3])
            ROI_LL=FindTemplateLL(template_LL[Target_Num-3])
            ROI_RR=FindTemplateRR(template_RR[Target_Num-3])
        ROI=[ROI_L,ROI_R,ROI_LL,ROI_RR]
        if not LoR and any(ROI):
            Target_ROI=[roi for roi in ROI if roi][0]
            FindedNum(Target_ROI,Target_Num)

#-------------------- 主函数 -------------------------

```

## 3、主要步骤

1. 初始化摄像头和基本参数，**有序 **读取图像模板。设置图像对比度，设置自动增益之后关闭（原理见[链接](# 9、增益)），减小分辨率，设置灰度图，手动划定窗口以减小计算量。
2. 串口接收并进行解码，得到任务码，并选择不同的处理方式。
   1. ==任务0==。保持现状
   2. ==任务1==。识别找到目标数字，具体方法如下。将帧图像与模板进行比较，如果都没有匹配到，就直接退出；如果匹配到，就找出目标所在的感兴趣区域和对应的真实数字，经过处理后发送给主控。
   3. ==任务2==。判断 LoR ，只有当其为0，也就是小车直走的时候再进行模板识别。接着，我们让帧图像和各个模板比较，找到目标区域，并把信息发送给主控。

## 4、效果展示

![](./1.jpg)

![](./2.jpg)

![](./3.jpg)
